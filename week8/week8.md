#7장. useReducer와 상태 관리

    - useReducer 이해하기
        사용시 컴포넌트에서 상태 변화 코드를 쉽게 분리 가능

    - 상태 변화 코드와 분리
        상태 변화 코드란? State 값을 변경하는 코드

        상태 변화 코드를 컴포넌트에서 분리하는 것 ->  컴포넌트 내부에 작성했던 상태 변화 코드를 외부에 작성하는 것
        **useState에서는 불가 그래서 useReducer 사용
        ***분리 이유 : 하나의 컴포넌트 안에 너무 많은 상태 변화 코드가 있으면 가독성 해침

    - useReducer의 기본 사용법
        State를 관리하는 리액트 훅
        -> 컴포넌트 내부가 아닌 외부에서 할 수 있게 함.

        useState와 달리 State를 관리하는 상태변화 코드를 컴포넌트와 분리 할 수 있음

        const [state변수, 상태 변화 촉발 함수] = useRedducer(상태 변화 함수,초깃값);

        *useReducer는 함수 reducer를 통해 상태 변화 코드를 컴포넌트 외부로 분리함. 만약 새로운 상태 변화가 필요하면, 함수 reducer를 다음과 같이 수정해 대응


#8장. 최적화

    - 최적화와 메모이제이션
        '최적화'란 한마디로 웹 서비스의 성능을 개선하는 기술
        불필요하게 낭비되는 연산 줄여 렌더링의 성능 높임

        리액트 앱에서 연산 최적화 = 메모이제이션 (메모하는 방법)
        -> 특정 입력에대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들어오면 저장한 결과값을 제공해 빠르게 응답하는 기술
        = 동적 계획법

    - 함수의 불필요한 재호출 방지하기
        useMemo
        -> 기본 사용법 
        : 특정 함수를 호출했을 때 그 함수의 반환값을 기억함 그리고 같은 함수를 다시 호출하면 기억해 두었던 값을 반환함
        즉, 함수으 ㅣ반환값을 다시구하는 불필요한 연산 삭제

        const value= useMemo(callback,deps);

    -불필요한 컴포넌트 리렌더 방지
        React.memo를 ㅣㅇ용해 메모이제이션 기법으로 컴포넌트가 불필요하게 리렌더되는 상황을 방지 가능

        **고차 컴포넌트와 횡단 관심사에 대한 이해 필요

            -고차 컴포넌트
            : 컴퓨ㅗ넌트의 기능을 다시 사용하기 위한 리액트의 고급 기술, 리액트 훅과 다름
            안수로 전달된 컴포넌트를 새로운 컴포넌트로 반환
            이때 그대로 반환 x 새로운 기능 추가함 

            -횡단 관심사
            : 프로그래밍에서 비즈니스 로직과 구분되는 공통 기능을 지칭할 때 사용하는 용어

        const memoizedComp = React.memo(Comp);


    -최적화할때 유의점
        항상 마지막에 !
        모든 것을 할 필요는 없음
        컴포넌트 구조를 잘 설게했는지 체크
        





